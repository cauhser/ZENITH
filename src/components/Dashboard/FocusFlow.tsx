import React, { useState, useEffect, useRef } from 'react';import { useStore } from '../../store';interface FocusSession {  id: string;  startTime: number;  endTime: number | null;  duration: number;  isCompleted: boolean;  distractions: number;  calmDuration: number;  wellnessPoints: number;  clarityBadges: string[];}const FocusFlow: React.FC = () => {  const { emotionalTrends } = useStore();  const [isRunning, setIsRunning] = useState(false);  const [timeLeft, setTimeLeft] = useState(25 * 60);   const [sessions, setSessions] = useState<FocusSession[]>([]);  const [currentSession, setCurrentSession] = useState<FocusSession | null>(null);  const [distractions, setDistractions] = useState(0);  const [calmDuration, setCalmDuration] = useState(0);  const [clarityBadges, setClarityBadges] = useState<string[]>([]);  const intervalRef = useRef<NodeJS.Timeout | null>(null);  useEffect(() => {    if (isRunning && timeLeft > 0) {      intervalRef.current = setInterval(() => {        setTimeLeft(prev => prev - 1);      }, 1000);    } else if (timeLeft === 0) {      finishSession();    } else if (intervalRef.current) {      clearInterval(intervalRef.current);    }    return () => {      if (intervalRef.current) {        clearInterval(intervalRef.current);      }    };  }, [isRunning, timeLeft]);  useEffect(() => {    let calmInterval: NodeJS.Timeout | null = null;    if (isRunning && distractions === 0) {      calmInterval = setInterval(() => {        setCalmDuration(prev => prev + 1);      }, 1000);    }    return () => {      if (calmInterval) {        clearInterval(calmInterval);      }    };  }, [isRunning, distractions]);  const startSession = () => {    if (isRunning) return;    const newSession: FocusSession = {      id: Date.now().toString(),      startTime: Date.now(),      endTime: null,      duration: 0,      isCompleted: false,      distractions: 0,      calmDuration: 0,      wellnessPoints: 0,      clarityBadges: []    };    setCurrentSession(newSession);    setIsRunning(true);    setTimeLeft(25 * 60);     setDistractions(0);    setCalmDuration(0);  };  const pauseSession = () => {    setIsRunning(false);  };  const resetSession = () => {    if (intervalRef.current) {      clearInterval(intervalRef.current);    }    setIsRunning(false);    setTimeLeft(25 * 60);    setDistractions(0);    setCalmDuration(0);    setCurrentSession(null);  };  const finishSession = () => {    if (intervalRef.current) {      clearInterval(intervalRef.current);    }    if (currentSession) {      const calmMinutes = Math.floor(calmDuration / 60);      const newWellnessPoints = calmMinutes;      const newBadges = getClarityBadges(calmMinutes, distractions);      const completedSession: FocusSession = {        ...currentSession,        endTime: Date.now(),        duration: 25 * 60 - timeLeft,        isCompleted: timeLeft === 0,        distractions,        calmDuration,        wellnessPoints: newWellnessPoints,        clarityBadges: newBadges      };      setSessions(prev => [completedSession, ...prev.slice(0, 9)]);       setClarityBadges(prev => [...new Set([...prev, ...newBadges])]);    }    setIsRunning(false);    setTimeLeft(25 * 60);    setDistractions(0);    setCalmDuration(0);    setCurrentSession(null);  };  const addDistraction = () => {    setDistractions(prev => prev + 1);  };  const getClarityBadges = (calmMinutes: number, distractionCount: number) => {    const badges = [];    if (calmMinutes >= 20) {      badges.push("Zen Master");    }    if (calmMinutes >= 15 && distractionCount <= 2) {      badges.push("Focus Champion");    }    if (distractionCount === 0) {      badges.push("Distraction Defender");    }    if (calmMinutes >= 10) {      badges.push("Calm Collector");    }    return badges;  };  const formatTime = (seconds: number) => {    const mins = Math.floor(seconds / 60);    const secs = seconds % 60;    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;  };  const getEmotionStatus = () => {    if (emotionalTrends.length === 0) return 'neutral';    const recentEmotion = emotionalTrends[emotionalTrends.length - 1];    if (recentEmotion.emotion === 'stressed' || recentEmotion.emotion === 'anxious') {      return 'stressed';    } else if (recentEmotion.emotion === 'happy' || recentEmotion.emotion === 'relaxed') {      return 'calm';    }    return 'neutral';  };  const emotionStatus = getEmotionStatus();  return (    <div className="focus-flow">      <div className="focus-flow-header">        <h3>üéØ Focus Flow</h3>        <p>Pomodoro + Emotion Guard</p>      </div>      <div className="focus-flow-content">        <div className="timer-section">          <div className="timer-display">            <div className="time">{formatTime(timeLeft)}</div>            <div className="timer-label">Focus Time Remaining</div>          </div>          <div className="timer-controls">            {!isRunning ? (              <button                 className="btn btn-primary start-btn"                onClick={startSession}                disabled={isRunning}              >                {currentSession ? 'Resume Focus' : 'Start Focus Session'}              </button>            ) : (              <button                 className="btn btn-secondary pause-btn"                onClick={pauseSession}              >                Pause              </button>            )}            <button               className="btn btn-secondary reset-btn"              onClick={resetSession}            >              Reset            </button>          </div>        </div>        <div className="emotion-guard">          <h4>Emotion Guard Status</h4>          <div className="emotion-status">            <div className={`emotion-indicator ${emotionStatus}`}>              {emotionStatus === 'stressed' && 'üò∞ Feeling Stressed'}              {emotionStatus === 'calm' && 'üòå Feeling Calm'}              {emotionStatus === 'neutral' && 'üòê Neutral'}            </div>            <div className="distraction-counter">              <button                 className="distraction-btn"                onClick={addDistraction}                disabled={!isRunning}              >                + Add Distraction              </button>              <div className="distraction-count">                Distractions: {distractions}              </div>            </div>            <div className="calm-tracker">              <div className="calm-time">                Calm Duration: {Math.floor(calmDuration / 60)}m {calmDuration % 60}s              </div>              <div className="calm-progress">                <div                   className="calm-fill"                  style={{ width: `${Math.min(100, (calmDuration / (25 * 60)) * 100)}%` }}                ></div>              </div>            </div>          </div>        </div>        {clarityBadges.length > 0 && (          <div className="clarity-badges">            <h4>üèÜ Clarity Badges Earned</h4>            <div className="badges-container">              {clarityBadges.map((badge, index) => (                <span key={index} className="badge">                  {badge}                </span>              ))}            </div>          </div>        )}        {sessions.length > 0 && (          <div className="session-history">            <h4>Recent Sessions</h4>            <div className="sessions-list">              {sessions.map((session, index) => (                <div key={session.id} className="session-item">                  <div className="session-info">                    <div className="session-duration">                      {Math.floor(session.duration / 60)}m {session.duration % 60}s                    </div>                    <div className="session-stats">                      <span>Distractions: {session.distractions}</span>                      <span>Calm: {Math.floor(session.calmDuration / 60)}m</span>                      <span>Points: +{session.wellnessPoints}</span>                    </div>                    {session.clarityBadges.length > 0 && (                      <div className="session-badges">                        {session.clarityBadges.map((badge, idx) => (                          <span key={idx} className="badge small">                            {badge}                          </span>                        ))}                      </div>                    )}                  </div>                  <div className="session-result">                    {session.isCompleted ? (                      <span className="completed">‚úÖ Completed</span>                    ) : (                      <span className="incomplete">‚è∏Ô∏è Paused</span>                    )}                  </div>                </div>              ))}            </div>          </div>        )}        {currentSession && (          <div className="session-summary">            <p>You stayed calm for {Math.floor(calmDuration / 60)} mins ‚Üí +{Math.floor(calmDuration / 60)} wellness points</p>            {getClarityBadges(Math.floor(calmDuration / 60), distractions).length > 0 && (              <p>Earned badges: {getClarityBadges(Math.floor(calmDuration / 60), distractions).join(', ')}</p>            )}          </div>        )}      </div>    </div>  );};export default FocusFlow;