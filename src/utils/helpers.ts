export const formatDate = (timestamp: number | string | Date): string => {  const date = new Date(timestamp);  return date.toLocaleDateString('en-US', {    year: 'numeric',    month: 'short',    day: 'numeric',    hour: '2-digit',    minute: '2-digit'  });};export const formatDuration = (ms: number): string => {  if (ms < 1000) return `${ms}ms`;  const seconds = Math.floor(ms / 1000);  if (seconds < 60) return `${seconds}s`;  const minutes = Math.floor(seconds / 60);  const remainingSeconds = seconds % 60;  if (minutes < 60) return `${minutes}m ${remainingSeconds}s`;  const hours = Math.floor(minutes / 60);  const remainingMinutes = minutes % 60;  return `${hours}h ${remainingMinutes}m`;};export const truncateText = (text: string, maxLength: number): string => {  if (!text || text.length <= maxLength) return text;  return text.substring(0, maxLength).trim() + '...';};export const generateId = (prefix: string = ''): string => {  const timestamp = Date.now().toString(36);  const random = Math.random().toString(36).substring(2, 9);  return `${prefix}${timestamp}_${random}`;};export const debounce = <T extends (...args: any[]) => any>(  func: T,  wait: number): ((...args: Parameters<T>) => void) => {  let timeout: NodeJS.Timeout;  return (...args: Parameters<T>) => {    clearTimeout(timeout);    timeout = setTimeout(() => func.apply(null, args), wait);  };};export const throttle = <T extends (...args: any[]) => any>(  func: T,  limit: number): ((...args: Parameters<T>) => void) => {  let inThrottle: boolean;  return (...args: Parameters<T>) => {    if (!inThrottle) {      func.apply(null, args);      inThrottle = true;      setTimeout(() => inThrottle = false, limit);    }  };};export const deepClone = <T>(obj: T): T => {  if (obj === null || typeof obj !== 'object') return obj;  if (obj instanceof Date) return new Date(obj.getTime()) as T;  if (obj instanceof Array) return obj.map(item => deepClone(item)) as T;  const cloned = {} as T;  for (const key in obj) {    if (obj.hasOwnProperty(key)) {      cloned[key] = deepClone(obj[key]);    }  }  return cloned;};export const deepEqual = (obj1: any, obj2: any): boolean => {  if (obj1 === obj2) return true;  if (typeof obj1 !== 'object' || obj1 === null ||       typeof obj2 !== 'object' || obj2 === null) {    return false;  }  const keys1 = Object.keys(obj1);  const keys2 = Object.keys(obj2);  if (keys1.length !== keys2.length) return false;  for (const key of keys1) {    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {      return false;    }  }  return true;};export const getDomainFromUrl = (url: string): string => {  try {    const urlObj = new URL(url);    return urlObj.hostname;  } catch {    return url;  }};export const calculatePercentage = (value: number, total: number): number => {  if (total === 0) return 0;  return Math.round((value / total) * 100);};export const formatNumber = (num: number): string => {  return new Intl.NumberFormat('en-US').format(num);};export const capitalize = (str: string): string => {  if (!str) return '';  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();};export const camelToKebab = (str: string): string => {  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();};export const kebabToCamel = (str: string): string => {  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());};export const isInRange = (value: number, min: number, max: number): boolean => {  return value >= min && value <= max;};export const clamp = (value: number, min: number, max: number): number => {  return Math.min(Math.max(value, min), max);};export const generateRandomColor = (): string => {  const colors = [    '#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6',    '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'  ];  return colors[Math.floor(Math.random() * colors.length)];};export const calculateAverage = (numbers: number[]): number => {  if (numbers.length === 0) return 0;  const sum = numbers.reduce((acc, num) => acc + num, 0);  return sum / numbers.length;};export const calculateStandardDeviation = (numbers: number[]): number => {  if (numbers.length === 0) return 0;  const average = calculateAverage(numbers);  const squareDiffs = numbers.map(num => Math.pow(num - average, 2));  const avgSquareDiff = calculateAverage(squareDiffs);  return Math.sqrt(avgSquareDiff);};export const groupBy = <T>(array: T[], key: keyof T): Record<string, T[]> => {  return array.reduce((groups, item) => {    const group = String(item[key]);    groups[group] = groups[group] || [];    groups[group].push(item);    return groups;  }, {} as Record<string, T[]>);};export const sortBy = <T>(array: T[], key: keyof T, ascending: boolean = true): T[] => {  return [...array].sort((a, b) => {    const aVal = a[key];    const bVal = b[key];    if (aVal < bVal) return ascending ? -1 : 1;    if (aVal > bVal) return ascending ? 1 : -1;    return 0;  });};export const filterFalsy = <T>(array: (T | null | undefined)[]): T[] => {  return array.filter((item): item is T => item != null);};export const removeDuplicates = <T>(array: T[], key?: keyof T): T[] => {  if (!key) {    return Array.from(new Set(array));  }  const seen = new Set();  return array.filter(item => {    const value = item[key];    if (seen.has(value)) return false;    seen.add(value);    return true;  });};export const sleep = (ms: number): Promise<void> => {  return new Promise(resolve => setTimeout(resolve, ms));};export const retryWithBackoff = async <T>(  fn: () => Promise<T>,  maxRetries: number = 3,  baseDelay: number = 1000): Promise<T> => {  let lastError: Error;  for (let attempt = 0; attempt < maxRetries; attempt++) {    try {      return await fn();    } catch (error) {      lastError = error as Error;      if (attempt < maxRetries - 1) {        const delay = baseDelay * Math.pow(2, attempt);        await sleep(delay);      }    }  }  throw lastError!;};export const isDevelopment = (): boolean => {  return process.env.NODE_ENV === 'development';};export const isProduction = (): boolean => {  return process.env.NODE_ENV === 'production';};export const safeJsonParse = <T>(str: string, fallback: T): T => {  try {    return JSON.parse(str) as T;  } catch {    return fallback;  }};export const safeJsonStringify = (obj: any, fallback: string = '{}'): string => {  try {    return JSON.stringify(obj);  } catch {    return fallback;  }};export const getCurrentISOTime = (): string => {  return new Date().toISOString();};export const getTimeDifference = (start: number | string | Date, end: number | string | Date): number => {  const startTime = new Date(start).getTime();  const endTime = new Date(end).getTime();  return endTime - startTime;};